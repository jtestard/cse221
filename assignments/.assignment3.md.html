<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Strict//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/Users/julestestard/Projects/git/courses/cse221/assignments/.assignment3.md.html</title>


<style type="text/css">
body {
	color: #333;
	font: 13px/1.4 Helvetica,arial,freesans,clean,sans-serif;
	font-family: sans-serif;
}

.markdown-body {
    border: 1px solid #CACACA;
    padding: 30px;
    font-size: 15px;
    line-height: 1.7;
    word-wrap: break-word;
}
.markdown-body > *:first-child {
    margin-top: 0 !important;
}
.markdown-body > *:last-child {
    margin-bottom: 0 !important;
}
.markdown-body a.absent {
    color: #C00;
}
.markdown-body a.anchor {
    bottom: 0;
    cursor: pointer;
    display: block;
    left: 0;
    margin-left: -30px;
    padding-left: 30px;
    padding-right: 6px;
    position: absolute;
    top: 0;
}
.markdown-body a.anchor:focus {
    outline: medium none;
}
.markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 {
    cursor: text;
    font-weight: bold;
    line-height: 1.7;
    margin: 1em 0 15px;
    padding: 0;
    position: relative;
}

.markdown-body h1 .octicon-link, .markdown-body h2 .octicon-link, .markdown-body h3 .octicon-link, .markdown-body h4 .octicon-link, .markdown-body h5 .octicon-link, .markdown-body h6 .octicon-link {
    color: #000;
    display: none;
}
.markdown-body h1:hover a.anchor, .markdown-body h2:hover a.anchor, .markdown-body h3:hover a.anchor, .markdown-body h4:hover a.anchor, .markdown-body h5:hover a.anchor, .markdown-body h6:hover a.anchor {
    line-height: 1;
    margin-left: -22px;
    padding-left: 0;
    text-decoration: none;
    top: 15%;
}
.markdown-body h1:hover a.anchor .octicon-link, .markdown-body h2:hover a.anchor .octicon-link, .markdown-body h3:hover a.anchor .octicon-link, .markdown-body h4:hover a.anchor .octicon-link, .markdown-body h5:hover a.anchor .octicon-link, .markdown-body h6:hover a.anchor .octicon-link {
    display: inline-block;
}
.markdown-body h1 tt, .markdown-body h1 code, .markdown-body h2 tt, .markdown-body h2 code, .markdown-body h3 tt, .markdown-body h3 code, .markdown-body h4 tt, .markdown-body h4 code, .markdown-body h5 tt, .markdown-body h5 code, .markdown-body h6 tt, .markdown-body h6 code {
    font-size: inherit;
}
.markdown-body h1 {
    border-bottom: 1px solid #DDD;
    font-size: 2.5em;
}
.markdown-body h2 {
    border-bottom: 1px solid #EEE;
    font-size: 2em;
}
.markdown-body h3 {
    font-size: 1.5em;
}
.markdown-body h4 {
    font-size: 1.2em;
}
.markdown-body h5 {
    font-size: 1em;
}
.markdown-body h6 {
    color: #777;
    font-size: 1em;
}
.markdown-body p, .markdown-body blockquote, .markdown-body ul, .markdown-body ol, .markdown-body dl, .markdown-body table, .markdown-body pre {
    margin: 15px 0;
}
.markdown-body hr {
    background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC") repeat-x;
    border: 0;
    color: #CCC;
    height: 4px;
    margin: 15px 0;
    padding: 0;
}
.markdown-body ul, .markdown-body ol {
    padding-left: 30px;
}
.markdown-body ul.no-list, .markdown-body ol.no-list {
    list-style-type: none;
    padding: 0;
}
.markdown-body ul ul, .markdown-body ul ol, .markdown-body ol ol, .markdown-body ol ul {
    margin-bottom: 0;
    margin-top: 0;
}
.markdown-body dl {
    padding: 0;
}
.markdown-body dl dt {
    font-size: 14px;
    font-style: italic;
    font-weight: bold;
    margin-top: 15px;
    padding: 0;
}
.markdown-body dl dd {
    margin-bottom: 15px;
    padding: 0 15px;
}
.markdown-body blockquote {
    border-left: 4px solid #DDD;
    color: #777;
    padding: 0 15px;
}
.markdown-body blockquote > *:first-child {
    margin-top: 0;
}
.markdown-body blockquote > *:last-child {
    margin-bottom: 0;
}
.markdown-body table {
    display: block;
    overflow: auto;
    width: 100%;
    border-collapse: collapse;
}
.markdown-body table th {
    font-weight: bold;
}
.markdown-body table th, .markdown-body table td {
    border: 1px solid #DDD;
    padding: 6px 13px;
}
.markdown-body table tr {
    background-color: #FFF;
    border-top: 1px solid #CCC;
}
.markdown-body table tr:nth-child(2n) {
    background-color: #F8F8F8;
}
.markdown-body img {
    -moz-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    -o-box-sizing: border-box;
    box-sizing: border-box;
    max-width: 100%;
    border: 0px;
}
.markdown-body span.frame {
    display: block;
    overflow: hidden;
}
.markdown-body span.frame > span {
    border: 1px solid #DDD;
    display: block;
    float: left;
    margin: 13px 0 0;
    overflow: hidden;
    padding: 7px;
    width: auto;
}
.markdown-body span.frame span img {
    display: block;
    float: left;
}
.markdown-body span.frame span span {
    clear: both;
    color: #333;
    display: block;
    padding: 5px 0 0;
}
.markdown-body span.align-center {
    clear: both;
    display: block;
    overflow: hidden;
}
.markdown-body span.align-center > span {
    display: block;
    margin: 13px auto 0;
    overflow: hidden;
    text-align: center;
}
.markdown-body span.align-center span img {
    margin: 0 auto;
    text-align: center;
}
.markdown-body span.align-right {
    clear: both;
    display: block;
    overflow: hidden;
}
.markdown-body span.align-right > span {
    display: block;
    margin: 13px 0 0;
    overflow: hidden;
    text-align: right;
}
.markdown-body span.align-right span img {
    margin: 0;
    text-align: right;
}
.markdown-body span.float-left {
    display: block;
    float: left;
    margin-right: 13px;
    overflow: hidden;
}
.markdown-body span.float-left span {
    margin: 13px 0 0;
}
.markdown-body span.float-right {
    display: block;
    float: right;
    margin-left: 13px;
    overflow: hidden;
}
.markdown-body span.float-right > span {
    display: block;
    margin: 13px auto 0;
    overflow: hidden;
    text-align: right;
}
.markdown-body code, .markdown-body tt {
    background-color: #F8F8F8;
    border: 1px solid #DDD;
    border-radius: 3px;
    margin: 0 2px;
    padding: 0 5px;
}
.markdown-body code {
    white-space: nowrap;
}
.markdown-body pre > code {
    border: medium none;
    margin: 0;
    padding: 0;
    white-space: pre;
}
.markdown-body .highlight pre, .markdown-body pre {
    background-color: #F8F8F8;
    border: 1px solid #DDD;
    border-radius: 3px;
    font-size: 13px;
    line-height: 19px;
    overflow: auto;
    padding: 6px 10px;
}
.markdown-body pre code, .markdown-body pre tt {
    border: medium none;
    margin: 0;
    padding: 0;
    word-wrap: normal;
}

pre, code, tt {
    font-family: Consolas,"Liberation Mono",Courier,monospace;
    font-size: 12px;
}

.highlight {
    background: #FFF;
}
.highlight .k,
.highlight .o,
.highlight .cp,
.highlight .cs,
.highlight .gs,
.highlight .gu,
.highlight .kc,
.highlight .kd,
.highlight .kn,
.highlight .kp,
.highlight .kr,
.highlight .kt,
.highlight .nc,
.highlight .ne,
.highlight .nf,
.highlight .ow {
    font-weight: bold;
}
.highlight .gd,
.highlight .gd .x,
.highlight .gi,
.highlight .gi .x,
.type-csharp .highlight .nf,
.type-csharp .highlight .nn {
    color: #000;
}
.highlight .c,
.highlight .cm,
.highlight .c1 {
    color: #998;
    font-style: italic;
}
.highlight .err {
    background-color: #E3D2D2;
    color: #A61717;
}
.highlight .cp,
.highlight .cs {
    color: #999;
}
.highlight .cs,
.highlight .ge {
    font-style: italic;
}
.highlight .gd {
    background-color: #FDD;
}
.highlight .gd .x {
    background-color: #FAA;
}
.highlight .gr,
.highlight .gt {
    color: #A00;
}
.highlight .gh {
    color: #999;
}
.highlight .gi {
    background-color: #DFD;
}
.highlight .gi .x {
    background-color: #AFA;
}
.highlight .go {
    color: #888;
}
.highlight .gp,
.highlight .nn {
    color: #555;
}
.highlight .gu,
.highlight .ni {
    color: #800080;
}
.highlight .kt {
    color: #458;
}
.highlight .m {
    color: #099;
}
.highlight .s {
    color: #D14;
}
.highlight .n {
    color: #333;
}
.highlight .na,
.highlight .no,
.highlight .nv,
.highlight .vc,
.highlight .vg,
.highlight .vi {
    color: #008080;
}
.highlight .nb {
    color: #0086B3;
}
.highlight .nc {
    color: #458;
}
.highlight .ne,
.highlight .nf {
    color: #900;
}
.highlight .nt {
    color: #000080;
}
.highlight .w {
    color: #BBB;
}
.highlight .mf,
.highlight .mh,
.highlight .mi,
.highlight .mo {
    color: #099;
}
.highlight .sb,
.highlight .sc,
.highlight .sd,
.highlight .s2,
.highlight .se,
.highlight .sh,
.highlight .si,
.highlight .sx,
.highlight .s1 {
    color: #D14;
}
.highlight .sr {
    color: #009926;
}
.highlight .ss {
    color: #990073;
}
.highlight .bp {
    color: #999;
}
.highlight .il {
    color: #099;
}
.highlight .gc {
    background-color: #EAF2F5;
    color: #999;
}
.type-csharp .highlight .k,
.type-csharp .highlight .kt {
    color: #00F;
}
.type-csharp .highlight .nf {
    font-weight: normal;
}
.type-csharp .highlight .nc {
    color: #2B91AF;
}
.type-csharp .highlight .s,
.type-csharp .highlight .sc {
    color: #A31515;
}

</style>


<script type="text/javascript">

function getDocumentScrollTop() 
{
   var res = document.body.scrollTop || document.documentElement.scrollTop || window.pageYOffset || 0;
   // alert(res);
   return res;
}

function setDocumentScrollTop(ypos) 
{
	window.scrollTo(0, ypos);
}

</script>


</head>
<body class="markdown-body">
<h1> <a id="user-content-assignment-3-cse-221" class="anchor" href="#assignment-3-cse-221" aria-hidden="true"><span class="octicon octicon-link"></span></a>Assignment 3 CSE 221</h1> 
<p>Jules Testard</p> 
<h2> <a id="user-content-section-1--eraser" class="anchor" href="#section-1--eraser" aria-hidden="true"><span class="octicon octicon-link"></span></a>Section 1 : Eraser</h2> 
<h3> <a id="user-content-part-1" class="anchor" href="#part-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Part 1</h3> 
<p><strong>What will the lockset algorithm conclude about how x, y and z are protected? Will it report one or more races? If not, explain why not. If so, explain what they will be and why they will be reported.</strong></p> 
<p>In this question, we assume that a new thread t1 starts executing the code fragment (not the main thread). We report in the following table the state of each variable, the locks held set, and the set of candidates lock of each variable after each instruction in the fragment. Empty cells in the table contain the same value as the cell above them.</p> 
<table> 
 <thead> 
  <tr> 
   <th>Program</th> 
   <th>State E=exclusive SM=SharedModified</th> 
   <th>locks_held(t)</th> 
   <th>C(x)</th> 
   <th>C(y)</th> 
   <th>C(z)</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td></td> 
   <td>{x = E, y = E, z = E}</td> 
   <td>{}</td> 
   <td>{a,b}</td> 
   <td>{a,b}</td> 
   <td>{a,b}</td> 
  </tr> 
  <tr> 
   <td>lock(a)</td> 
   <td></td> 
   <td>{a}</td> 
   <td></td> 
   <td></td> 
   <td></td> 
  </tr> 
  <tr> 
   <td>y := x + 1</td> 
   <td>{x = SM, y = SM, z = E}</td> 
   <td></td> 
   <td>{a}</td> 
   <td>{a}</td> 
   <td></td> 
  </tr> 
  <tr> 
   <td>lock(b)</td> 
   <td></td> 
   <td>{a,b}</td> 
   <td></td> 
   <td></td> 
   <td></td> 
  </tr> 
  <tr> 
   <td>z = y+1</td> 
   <td>{x = SM, y = SM, z = SM}</td> 
   <td></td> 
   <td></td> 
   <td></td> 
   <td></td> 
  </tr> 
  <tr> 
   <td>y = x+1</td> 
   <td></td> 
   <td></td> 
   <td></td> 
   <td></td> 
   <td></td> 
  </tr> 
  <tr> 
   <td>unlock(a)</td> 
   <td></td> 
   <td>{b}</td> 
   <td></td> 
   <td></td> 
   <td></td> 
  </tr> 
  <tr> 
   <td>unlock(b)</td> 
   <td></td> 
   <td>{}</td> 
   <td></td> 
   <td></td> 
   <td></td> 
  </tr> 
 </tbody> 
</table> 
<p>The lockset algorithm concludes that all variables are protected at all times. It will not report any races, because the set of candidate locks is non-empty for all variables at all times.</p> 
<h3> <a id="user-content-part-2" class="anchor" href="#part-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>Part 2</h3> 
<p><strong>We add a new code sequence, that is executed by some other thread on the same program (not necessarily by the thread from the question above). What will the lockset algorithm conclude about how x, y and z are protected? Will it report one or more races? If not, explain why not. If so, explain what they will be and why they will be reported.</strong></p> 
<p>In this question, we assume a new thread t2 starts executing the code fragment (t2 different from t1). We consider that the previous code fragment has already been executed by t1, therefore the state and set of candidate locks of each variable is inherited from the above.</p> 
<table> 
 <thead> 
  <tr> 
   <th>Program</th> 
   <th>State E=exclusive SM=SharedModified</th> 
   <th>locks_held(t1)</th> 
   <th>C(x)</th> 
   <th>C(y)</th> 
   <th>C(z)</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td></td> 
   <td>{x = SM, y = SM, z = SM}</td> 
   <td>{}</td> 
   <td>{a}</td> 
   <td>{a}</td> 
   <td>{a,b}</td> 
  </tr> 
  <tr> 
   <td>lock(b)</td> 
   <td></td> 
   <td>{b}</td> 
   <td></td> 
   <td></td> 
   <td></td> 
  </tr> 
  <tr> 
   <td>lock(a)</td> 
   <td></td> 
   <td>{a,b}</td> 
   <td></td> 
   <td></td> 
   <td></td> 
  </tr> 
  <tr> 
   <td>y = x -1</td> 
   <td></td> 
   <td></td> 
   <td></td> 
   <td></td> 
   <td></td> 
  </tr> 
  <tr> 
   <td>unlock(b)</td> 
   <td></td> 
   <td>{a}</td> 
   <td></td> 
   <td></td> 
   <td></td> 
  </tr> 
  <tr> 
   <td>z = z +1</td> 
   <td></td> 
   <td></td> 
   <td></td> 
   <td></td> 
   <td>{a}</td> 
  </tr> 
  <tr> 
   <td>unlock(a)</td> 
   <td></td> 
   <td>{}</td> 
   <td></td> 
   <td></td> 
   <td></td> 
  </tr> 
 </tbody> 
</table> 
<p>The lockset algorithm concludes that all variables are protected at all times. It will not report any races, because the set of candidate locks is non-empty for all variables at all times.</p> 
<h3> <a id="user-content-part-3" class="anchor" href="#part-3" aria-hidden="true"><span class="octicon octicon-link"></span></a>Part 3</h3> 
<p><strong>Aside from data races the Eraser paper briefly mentions how a similar technique might be used to detect deadlock. Explain how such a scheme could detect a deadlock in the previous code examples (be specific about what the deadlock is).</strong></p> 
<p>The program run by t1 locks a then b (before releasing any locks). The program run by t2 locks b then a in the same fashion. If t1 locks a and t2 locks b immediately afterwards, the deadlock would be caused.</p> 
<p>Lets assume locks are sorted in lexicographic order. Then, according to the discipline proposed in the paper, then the program executed by t2 would generate a warning when execute, because lock b is acquired before lock a. </p> 
<h2> <a id="user-content-section-2--schedular-activations" class="anchor" href="#section-2--schedular-activations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Section 2 : Schedular Activations</h2> 
<h2> <a id="user-content-section-3--lfs" class="anchor" href="#section-3--lfs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Section 3 : LFS</h2> 
<h3> <a id="user-content-part-1-1" class="anchor" href="#part-1-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Part 1</h3> 
<p><strong>Explain what are the assumptions about hardware and access patterns that LFS depends on</strong></p> 
<ol> 
 <li>In LFS, the hardware is assumed to be a hard disk. As such, reading/writing blocks sequentially is assumed to be much faster than reading blocks at random locations. </li> 
 <li>Moreover, the LFS authors notice that RAM sizes (thus file cache sizes) have increased at a much faster rate than disk bandwidth. As a result, the authors anticipate that most read requests will affect data stored on cache, leaving the disk workload to be primarily write-based. Thus, in order to achieve the best possible performance, write performance should be privileged at the possible detriment of read performance.</li> 
 <li>In addition, the LFS authors notice that bigger cache sizes also allow write buffering (accumulating write requests in a buffer). Given that writes do not have to be sent to disk immediately, a strategy to position them efficiently on disk can be put in motion.</li> 
 <li>Finally, the authors notice that not all files are accessed with the same frequency. A minority of files (hot files) are read/written much more often than the majority (cold files). </li> 
</ol> 
<h3> <a id="user-content-part-2-1" class="anchor" href="#part-2-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Part 2</h3> 
<p><strong>Explain which mechanisms in LFS depend on each assumption</strong></p> 
<p>We consider here three major mechanisms of the LFS : </p> 
<ol> 
 <li> <strong>The writing mechanism for LFS</strong> is behind the fundamental idea of a log structured file system. Given the hard disk assumption, it is inconvenient to write to random locations on the file system. Instead, LFS chooses to write all of the incoming changes sequentially, even if they correspond to unrelated files. Moreover, all of the changes are done in one write, which is possible given the assumed large size of the write buffer.</li> 
 <li> <strong>The reading mechanism for LFS</strong> is more similar to that of traditional file systems (such as FFS). An inode data structure contains pointers to the file's disk blocks. However, inodes need to be retrieved somehow, because that how no longer stored on a fix location (as in FFS), but written like everything else at the end of the log. Therefore, an additional layer of indirection (given by an inode map) is required. This makes reads slightly slower or just as good as FFS, which is not such a big problem given the workload isn't expected to be read heavy.</li> 
 <li> <strong>The cleaning mechanism for LFS</strong> is required to guarantee free space to be constantly available in the disk and to avoid fragmentation of the log. This is done by loading into memory (fragmented) segments of data and write them (sequentially) back to disk. The read segments are now marked as free. This is made possible by the large file cache assumption, allowing to load the segments in memory. The authors thread very carefully with the loaded segments because some of the data could be &quot;live&quot; (about to be edited). Given the hot/cold assumption, by focus on moving around cold files, the problem of having updates on segments being cleaned happens less often.</li> 
</ol> 
<h3> <a id="user-content-part-3-1" class="anchor" href="#part-3-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Part 3</h3> 
<p><strong>At the time the LFS paper was written, non-volatile RAM (NVRAM) was not commonly available. If disks were replaced with NVRAM entirely, would the LFS design still make sense? Explain why or why not and be specific in justifying your answer.</strong></p> 
<p>The seek time for data in NVRAM is no longer limited by the movement of a mechanical arm. This makes random accesses much faster and reading sequentially less important. The LFS gets its write performance from the fact that all of its writes are sequential. LFS's write performance dominance will be crippled because its performance will not increase as much as that of other file systems such as FFS. The drawback of having to clean segments, however, will remain. As a result, the design is likely to become less attractive in such an environment.</p> 
<h3> <a id="user-content-part-4" class="anchor" href="#part-4" aria-hidden="true"><span class="octicon octicon-link"></span></a>Part 4</h3> 
<p><strong>In real-life the cost per byte of disk is likely to be far cheaper than NVRAM for some time. So instead, consider a situation where some NVRAM is available (e.g., 1/10th of the disk size). This NVRAM might be used for caching reads, caching writes, or storing particular meta-data. Argue which use might be most appropriate for improving the performance of LFS.</strong> </p> 
<p>Managing metadata in LFS is currently cumbersome. An extra layer of indirection (the inode map) is required. Whenever a file is updated, this map must be update as well. The inode is not appended to the log like other writes, because it must be easy to find. Having the inode map located in NVRAM would benefit both read and write performance.</p> 
<p>Another use of the NVRAM could be read caching. Reading data is where LFS does not perform well, an extra layer of caching could only be beneficial to the overall performance. </p>
</body>
</html>
