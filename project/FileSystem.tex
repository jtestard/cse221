\subsection{File Cache Size}

\subsubsection{Estimation}

\subsubsection{Methodology}

\subsubsection{Results}

\subsubsection{Analysis}

\subsection{File Read Time}

In this section, we describe the time taken to read a file sequentially or randomly.

\subsubsection{Estimation}

Sequential access of a file is when we get the most out of the disk bandwidth. According to our vendor's specification, the maximum read throughput is 520MB/s. We are using a trick : we are not reading off a file that we have created. Rather, we are reading directly of from a disk partition, using a special file : \texttt{/dev/sda1}. In linux systems, \texttt{/dev/sda[x]} is the name of the special file representing disk partition \texttt{x}. There is no reason for a disk partition to be scattered across the disk (the way a user-generated file could be), therefore we can expect our disk access to be almost truly sequential (we still might have to fetch metadata on some other partition). As seen in class, we expect random access to be a lot slow than sequential access when accessing a file through disk. However, our machine uses a SSD, which are known to have much better seek times than traditional hard drives. 

\subsubsection{Methodology}

In order to ensure we are reading from disk and not from the file cache, we use the Linux flag \texttt{O\_DIRECT}. The \texttt{O\_DIRECT} flag can be specified when making the \texttt{open} system call. If used, it guarantees all read and write system calls on the opened file descriptor will fetch data from disk. It uses 

To read randomly, we also read directly from the disk partition. We use the Linux lseek() command which reads at an offset of a file descriptor, as follows:

numblocks = SIZE_OF_FILE;
offset = (off64_t) numblocks * random() / RAND_MAX;
retval = lseek64(fd, BLOCKSIZE * offset, SEEK_SET);
Where fd is the file seeked (in our case the disk partition), offset is the randomly chosen offset. SEEK_SET is an option which tells the lseek() command to start offsetting from the beginning of the file. Finally, we simulate files of varying size by changing the numblocks variable.

To avoid the file system cache, we use O_DIRECT.

To obtain the block size, we used the command : blockdev --getbsz /dev/sda1. We found it was 4096.

\subsubsection{Results}


\subsubsection{Analysis}

\subsection{Remote File Read Time}

\subsubsection{Estimation}

\subsubsection{Methodology}

\subsubsection{Results}

\subsubsection{Analysis}

\subsection{Contention}

\subsubsection{Estimation}

\subsubsection{Methodology}

\subsubsection{Results}

\subsubsection{Analysis}
